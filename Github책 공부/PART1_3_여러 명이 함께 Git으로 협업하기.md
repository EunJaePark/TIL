### 01. 원격저장소에서 협업하기: 브랜치(Branch)
- 브랜치(Branch): 특정 기준에서 줄기를 나누어 작업할 수 있는 기능

#### 1) 두 명이 동시에 버전 관리를 해야 한다면?
- 서로의 작업물에 의존하지 않고 내가 원할 때 코드를 올리고, 내가 원할 때 협업자의 코드와 합칠 수 있어야한다.

#### 2) Git이 커밋을 관리하는 방식: 줄줄이 기차
- 병렬 버전 관리

#### 3) 브랜치, 정체를 밝혀라!
- [HEAD]라는 특수한 포인터를 이용해 브랜치 사이를 넘나들 수 있다.(타임머신 역할)
- [HEAD]가 master브랜치가 아닌 이전의 커밋을 가리키게 하면 '분리된 HEAD(Detached HEAD)'상태가 된다.

<br/>

### 02. 브랜치 실습 기본: 만들고, 이동한다
- 협업을 하기 위해서는 브랜치를 만들고, 이동하면 된다.
  1. 협업자는 커밋을 올릴 브랜치를 각각 만들고,
  2. 자신이 만든 브랜치로 이동한 다음,
  3. 브랜치에 커밋을 올리고,
  4. 코딩이 완료되면 브랜치를 합치면 된다.
  
- 이 과정을 소스트리에서 해보자.

#### 1) 새 브랜치 만들기
- 브랜치 이름에 `/`를 넣으면 `/`의 앞에 적은 텍스트가 폴더처럼 구분되어 보여진다.
- 소스트리 상단의 [브랜치]를 클릭해 새 브랜치 이름을 기입 후 [새 브랜치 체크아웃]을 체크 한뒤 새 브랜치를 생성해준다.
  - [체크아웃(checkout)]은 브랜치를 이동하는 명령어이다.
  - [새 브랜치 체크아웃]을 하지 않으면 새로운 브랜치는 생성되지만 [HEAD]는 여전히 [master]브랜치를 가리키게 된다.
- VSCode에서 새로운 파일을 생성 후 소스트리에서 커밋을 해주면, 새로 생성한 브랜치에 커밋이 추가된 것을 확인할 수 있다.
- 기존에 있던 .md파일을 수정 후 커밋할 때 [-에 바뀐 내용 즉시 푸시]를 체크해서 커밋하면 새 브랜치에 추가된 커밋까지 한번에 push가 가능하다.

- push 후, GitHub의 해당 원격저장소에서 좌측의 [Branch:master]드롭다운 버튼을 클릭해 보면, 새로 생성한 브랜치이름을 확인할 수 있다.
  - 새로운 브랜치 이름을 클릭하면 새로운 브랜치에 커밋된 파일들도 확인이 가능하다.

#### 2) 브랜치 이동하기: 체크아웃(checkout)
- 브랜치를 생성할 때에는 base브랜치를 잘 설정해야한다.
- 새로운 브랜치를 생성해보자.
  - 실습에서는 base브랜치를 master로 해놔야 브랜치가 섞이지 않겠지!
  
- 소스트리 좌측의 [브랜치]에서 master브랜치를 더블클릭(또는 우클릭 후 [master 체크아웃]선택)을 해서 base브랜치를 master로 수정해준다.
- 새로운 브런치를 생성해준다.
- 새로운 브런치 생성 후 이전 브랜치에서 수정한 .md파일을 열어보면 수정한 내용이 사라져있다.(이전 버전으로 보임)
- 해당 .md파일에서 이전과는 다르게 수정을 해본다.(이후 브랜치를 합칠 때 충돌이 발생할 것이다)
- 새로운 .md파일을 생성후 커밋해준다.([-에 바뀐 내용 즉시 푸시]에 체크해 push까지 한번에 해주자)
- 소스트리의 그래프가 두 갈래로 나뉜 것을 볼 수 있다.

- 이 처럼 각자의 브랜치에서 개발하다가 각자의 개발이 완료되면 [master]브랜치에 내 브랜치 작업물을 합치면 되는 것이다.
  - 실습에서는 [master]브랜치를 base로 각각의 브랜치를 만들었기 때문에 [master]브랜치에서 합치는 것이다.
 
 <br/>
 
### 03. 브랜치와 브랜치를 합치기: 병합(merge, 머지)
- 각각의 브랜치를 만들어 병렬 작업한 것을 작업이 끝나면 하나로 합쳐야한다.

#### 1) 병합은 무엇인가요?
- 병합 커밋(Merge commit) : 커밋1과 커밋2의 내용이 합쳐져 새로운 커밋3 생성.
- 빨리 감기 병합(Fast-forward) : 커밋1 + 커밋2를 했을 때 결과물이 커밋2인 경우.
- 충돌(Conflict) : 커밋1과 커밋2의 같은 부분이 서로 다른 내용일 경우 충돌.

#### 2) 두 브랜치를 합치는 과정
- merge : Git에서 브랜치와 브랜치를 합치는 명령어
- '병합 커밋'일 경우 새로 만들어진 병합커밋을 어떤 브랜치에 올릴지는 상황에 따라 선택하면 된다.
  - 실습에서는 [master]브랜치로 올릴 것이다.

#### 3) 브랜치 합치기 실습: 빨리 감기 병합
- base브랜치로 체크아웃 해준다.
- 병합하기 원하는 커밋에서 우클릭 후 [병합]을 선택한다.
  - 좌측 사이드바의 [브랜치]에서 병합하려는 브랜치에서 우클릭 후 [현재브랜치로 ~~ 병합]을 선택해도 된다.
- 병합을 선택하면 해당 브랜치를 병합할 것인지를 묻는 팝업창이 뜬다.
  - [fast-forward가 가능해도 새 커밋으로 생성]에 체크하면 빨리 감기 병합이 가능하더라도 명시적으로 병합 커밋을 만든다.
    - 하지만 맥 소스트리에서는 팝업창에 이 체크사항이 없었다.
- 로컬저장소 내에서만 병합이 일어난 상태이므로, 소스트리를 보면 [master]브랜치와 병합한 브랜치2개 총 3개의 브랜치 이름이 해당 커밋에 나타난다.

- 소스트리 상단의 [푸시]를 해주면 원격저장소에도 병합한 브랜치가 올라간다.
  - [master]브랜치로 병합을 올렸기 때문에, [푸시]에서 master브랜치를 체크하고 push하면 된다.

<br/>

### 04. 앗! 둘이 똑같은 코드를 고쳤어요: 충돌(conflict) 해결하기
#### 1) 브랜치 합치기 실습: 병합 커밋 및 충돌 해결
- 두 커밋이 같은 코드를 수정했다면 병합 커밋을 만들다가 충돌이 일어날 수 있다.
- 따라서, 나만 쓰는 브랜치에서 먼저 병합을 해보고, 병합된 커밋이 문제가 없는 것을 확인 후 협업하는 브랜치에 반영한다.  
  ___
- 개인 브랜치로 체크아웃을 한다.
- [master]의 최근 병합 브랜치를 병합해준다.
- 충돌을 알리는 팝업창이 뜬다.
- 소스트리 그래프 옆의 설명에서 `커밋하지 않은 변경사항(Uncommitted changes)`을 클릭하면, 병합충돌이 일어난 파일이 스테이지에 올라가지 않은 상태인 것을 확인할 수 있다.
- 따라서, 해당 파일을 수정하면 병합을 무사히 진행할 수 있다.

- VSCode에서 충돌이 일어난 코드가 자동으로 마크되어있는 것을 확인할 수 있다.
- 코드를 수정해준다.(충돌이 난 코드 위에 적힌 버튼을 클릭해도 된다 -VSCode에서만 제공하는 편의기능)
- 커밋 후 푸시해준다.
- 개인 브랜치에서 충돌이 해결된 것을 확인했으니, 협업 브랜치에도 올려준다.

<br/>

### 05. 브랜치를 합치는 예의바른 방법: 풀 리퀘스트
- 풀 리퀘스트: 협력자에게 브랜치 병합을 요청하는 메세지를 보내는 것.
  - GitHub의 풀 리퀘스트 버튼은 자동으로 메세지를 만들어 준다.

#### 1) 풀 리퀘스트 만들기
- 새로운 브런치를 생성하고 새로운 .md파일을 생성 후 커밋, 푸시해준다.
- GitHub에서 해당 커밋을 보면 새롭게 생성된 브런치를 알려주는 노란색 알림박스를 볼 수 있다.
  - 노란 박스의 우측에 초록색의 [Compare & pull request]버튼이 풀 리퀘스트 요청 버튼이다.
  - 이 버튼은 최근에 푸시한 브랜치가 있을 때만 나타난다.
  - 다른 브랜치로 풀 리퀘스트를 보내거나 직접 변경하고 싶을 경우에는 그 아래줄 좌측의 [New pull request]버튼을 이용하면 된다.
  
- [Compare & pull request]버튼 클릭 후.
    - base브랜치와 compare브랜치를 선택한다.
      - base브랜치: 병합 결과물이 올라갈 브랜치.
      - compare브랜치: 현재 base브랜치(기준브랜치)의 비교대상이 되는 브랜치.
    - 우측 사이드바의 [Reviewer]를 클릭하면 협력자를 지정할 수 있다.
    - [Assignees]에는 풀 리퀘스트를 담당하는 동료를 적어준다. 보통 자기자신이다.
    - [Labels]에는 풀 리퀘스트에 관한 라벨을 달아준다. ex) [버그], [리뷰 필요], [프런트엔드], [백엔드] 등..
    
- 풀 리퀘스트 요청을 보내고, 이상이 없다고 판단되면 상대방이 [Merge pull request]버튼을 눌러 병합을 승인할 것이다.
- 풀 리퀘스트가 성공적으로 병합된 후에는 닫혔다는 메세지가 보인다.
  - 닫혀진 풀 리퀘스트는 GitHub의 [Pull request]탭의 [Closed]에서 확인 가능하다.

- 소스트리에서는 풀 리퀘스트 요청으로 병합된 파일이 아닌 그 전단계의 파일을 [origin/master]이 가리키고 있을 것이다.
  - [패치](Git에서 새로운 이력을 업데이트 하는 명령어)를 클릭해 그래프를 업데이트 해준다.
- 로컬저장소인 [master]브랜치에도 이 새로운 커밋을 반영하기 위해 [master]로 체크아웃 해준다.
  - 체크아웃 후 소스트리 상단의 [풀(pull)]버튼 이용해서 원격저장소와 동일하게 바꿔준다.

<br/>

### 06. 개발이 완료되었습니다, 출시하자!: 릴리즈(release)
#### 1) 프로그램의 버전(version)이란?
- 프로그램을 출시할 때, 업그레이드 할 때 버전을 명시하는 것처럼 Git에서 말하는 버전도 비슷하다.   
  의미있는 특정 시점의 맥락을 말하는 것이다.
  
- 버전을 올리는 것은 크게 2가지로 나뉜다.  
  - 메이저(Major) 업그레이드 : 사용자가 크게 느낄 변화를 업그레이드 했을 때.
  - 마이너(Minor) 업그레이드 : 작은 변화가 생겼을 때.
- LTS: (Long Time Support) 장기 지원 버전.
- 메인터넌스(Maintenance) 버전 : 버그나 유지보수 등 작은 수정이 들어갔을 때.

#### 2) 특정 커밋에 포스트잇 붙이기 - 태그(tag)
- 현재 코드 상태 버전을 태그(tag)를 통해 간단하게 표시할 수 있다.
- 해당 브랜치로 체크아웃 후 소스트리 상단의 [태그]버튼을 클릭한다.
  - 맥에서는 소스트리 상단에 [태그]버튼이 존재하지 않았다.    
    따라서, 태그하려는 커밋에서 우클릭 후 [태그]를 선택했다.  
    선택 후, 책과 같게 [작업사본부모]에 체크를 하고 [명시된 커밋]에 적힌 커밋번호를 지워줬다.
    
- 그래프 설명의 해당 커밋의 브랜치 옆에 추가된 [태그]내용이 뜬다.
  - 브랜치와 비슷하게 생겼다. 둘 다 커밋을 가리키는 가벼운 포인터이기 때문이다.
- 만든 태그는 push를 해줘야 원격저장소에서도 볼 수 있다.
- 소스트리 상단의 [푸시]클릭 후 해당 브랜치 체크, [모든 태그 푸시]체크를 해준다.

- GitHub의 해당 원격저장소에서 [1 release]라는 버튼을 누르면 추가된 태그를 확인할 수 있다.
  - 방금 만든 태그 아래 [zip]아이콘을 누르면 해당 태그가 가리키는 버전을 압축 파일로 내려받을 수 있다.
