<h1>< vue.js 끝장내기 - 실무에 필요한 모든 것 ></h1>

<h2>1. 강의 오리엔테이션</h2>

<h3> 2강 (현대 프런트엔드 개발 절차와 역할) </h3>

- 현대 웹 서비스 개발 절차

    : 요구사항 -> 서비스 기획 -> UI, UX 상세 설계 -> GUI 디자인 -> 퍼블리싱 -> 백엔드 API 개발 -> 프런트엔드 개발 -> QA
- 프런트엔드 개발자의 역할 :
	- 화면단 코드 작성
	- 기획, 디자인, 퍼블리싱, 백엔드 개발자와 소통 (커뮤니케이션의 역할이 크다)


<h3> 3강 (수업에서 사용할 API 문서 소개) </h3>

- 백엔드 개발자가 정한 API 문서를 보고 이해하고 소통하고 개발할 줄 알아야한다.
- Swagger( https://swagger.io/ ) : API문서를 자동화하는 도구.
- 이 수업에서 목적으로 하는 것은 API 문서를 보고 백엔드 개발자와 어떤 식으로 소통하고 협업해야 하는지를 아는것!


<hr/>


<h2>2. 개발환경 구성</h2>

<h3> 4강 (개발 환경 소개) </h3>

- 깃헙 리포지토리 링크 :
https://github.com/joshua1988/vue-til

- 프로그램 설치 안내 동영상 - Vue.js 시작하기 :
https://www.inflearn.com/course/Age-of-Vuejs/lecture/21333

- 개발환경 목록 페이지 링크 :
https://github.com/joshua1988/vue-til/tree/master#%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD



<h3> 5강 (VSCode 플러그인 및 테마 설정) </h3>

- VSCode 명령어 팔레트 단축키
     - 윈도우 : Ctrl + Shift + P    
     - 맥 : Cmd + Shift + P

- VSCode 플러그인 설치 및 설정 동영상 - Vue.js 시작하기 :
https://www.inflearn.com/course/Age-of-Vuejs/lecture/21397



<h3> 6강 (API 서버 프로젝트 구성) </h3>

- API 서버 깃헙 리포지토리 주소 :
https://github.com/joshua1988/vue-til-server


- $node -v : 터미널에서 v10이상이어야 의미있는 설치가 된다. 버전10 이상일 때 npm i ~를 해주자.

<img src="./imgs/end6.png" />



<h3> 7강 (Node.js 버전 관리가 필요한 이유와 버전 변경하는 방법) </h3>

- 프로젝트마다 node.js버전을 변경할 필요가 있다. 모든 프로젝트가 최신은 아니기 때문.
- 이번 강의에서는 node.js버전을 낮춰줘야 한다.
- node.js사이트에서 ‘다운로드’메뉴에서 페이지 아래에 있는 ‘이전릴리즈’를 클릭 한 후, 원하는 버전을 다운받으면 된다.
- 이번 강의에서는 v10.16.~ 버전이면 된다.

- Node.js 이전 릴리즈 다운로드 페이지 :
	https://nodejs.org/ko/download/releases/
- OS 별로 아래 파일을 다운로드 받으시면 됩니다 :)
	- 윈도우 64비트 : x64-msi 파일
	- 윈도우 32비트 : x86-msi 파일
	- 맥 : pkg 파일
	- 리눅스 : tar 파일



<h3> 8강 (NVM(Node Version Manager) 소개 및 설치) </h3>

- 아래의 명령어를 터미널에 입력하면 NVM 설치됨.

		curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash
	===> 주의해야할 점은 마지막이 bash라고 되어있어야 한다. 

- 위의 설치를 한 후 터미널에 nvm -v을 입력해서 버전을 확인하면 확인이 안된다.
- 그 이유는 어딘가에 저장을 해줘야하기 때문인데, 이를 해결해보자.

- 터미널에   vi ~/.bashrc 를 입력해준다.(리눅스 편집기를 이용해서 편집할 파일을 연결)
- 아래의 명령어를 입력한 후, ‘esc’키를 눌러줘서 쓰기모드를 해제한다. 그 후, :wq를 입력하고 엔터를 누르면 저장이 된다. (만약 저장하지 않고 그냥 나가려면 :q를 입력하면 종료된다.)( :q! 는 강제종료!!)

		export NVM_DIR="$([ -z "${XDG_CONFIG_HOME-}" ] && printf %s "${HOME}/.nvm" || printf %s "${XDG_CONFIG_HOME}/nvm")"
		[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" # This loads nvm


	=====> 내 컴퓨터(맥북)에 설치할 때 그냥 vi ~/.bashrc로 들어가서 입력하니까 nvm을 찾을 수가 없다고만 나와서 vi ~/.bash_profile로 들어가서 설치해 줬더니 성공했다!

- NVM 깃헙 설치 링크 :
https://github.com/nvm-sh/nvm#installing-and-updating





<h3> 9강 (NVM으로 Node.js 버전 변경 및 설치) </h3>

- NVM 설치 및 버전 변경 절차 문서 :
https://github.com/joshua1988/vue-til-server#nvm-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EB%B2%84%EC%A0%84-%EB%B3%80%EA%B2%BD-%EB%B0%A9%EB%B2%95

- 만약 노드 버전을 그냥 전환하고 싶다면  `nvm use 버전 이름`을 써보세요 :)



<h3> 10강 (API 서버 실행 및 확인) </h3>

- npm i 로 라이브러리 설치.
- npm run dev 로 서버 실행. 
    - 실행하고 나면 터미널에 VUE TIL SERVER IS RUNNING ON 3000라고 뜬다.
    - 3000은 app.js파일의 중간부분에 적혀있으므로, 만약 3000이라는 로컬주소가 존재할 경우 기존에 존재하는 3000을 끄던지, app.js에서 3000을 다른 숫자(ex)4000)으로 바꿔주면 된다.
    
			// server setup
			let port;
			async function configServer() {
			  port = 3000 || (await detectPort(3000));
			}
			configServer();

    - 제대로 서버가 실행됬는지 확인하려면 브라우저에서 localhost:3000이라고 쳐보자.
    - 화면에 Cannot GET /라고 뜨면 제대로 된것.




<h3> 11강 (데이터 베이스 연결 안내) </h3>

- 기본적으로 node.js어플리케이션은 app.js를 기준으로 실행되고 있다.




<h3> 12강 (MongoDB Cloud 사이트 소개 및 회원 가입 안내) </h3>


- MongoDB Cloud 사이트 :
https://www.mongodb.com/cloud

==> MongoDB 가입. (id:desi~@na~, pw:기본x1 )




<h3> 13강 (MongoDB 인스턴스 생성 후 Node.js에 연결) </h3>

- Free 클러스터 이용하자..!
- MongoDB를 생성하고, 생성한 주소를 app.js의 중간에 있는 부분에 넣어준 후, 다시 npm run dev를 해준다. ( 이때 터미널에 200번대가 찍히면 성공한 것 )

		mongoose.connect(
		  'mongodb+srv://test:1234@cluster0-tb8u4.mongodb.net/test?retryWrites=true&w=majority',
		  {
		    useNewUrlParser: true,
		  },
		);

- localhost:3000/api/docs : 브라우저에 이 주소를 치면 내가 설치한 api 문서를 확인 가능하다.

- 여기까지가 API를 Swagger라는 라이브러리를 이용해 짠 것이다.




<h3> 14강 (API 문서 보는 법과 사용하는 방법) </h3>

- localhost:3000/api/docs에서 API를 돌려보고 확인해 볼 수 있는 것이다.(편하게 Swagger를 이용해서)


<hr/>


<h2>3. 프로젝트 생성 및 환경 구성</h2>

<h3> 15강 (Vue CLI로 프로젝트 생성) </h3>

- Vue CLI 설치 안내 페이지 :
https://cli.vuejs.org/guide/installation.html

- 프로젝트 설치 옵션
	- Manually select features
	- Babel, Linter, Unit
	- Prettier
	- Lint on Save
	- Jest
	- In dedicated config files
	- n



<h3> 17강 (ESLint 에러가 화면에 표시되지 않게 하는 방법) </h3>

<img src="./imgs/end17_1.png" />

- ESLint 에러가 나지않는 더 좋은 코드를 작성할 수 있도록 도와주는 것이지, 에러는 실질적으로 애플리케이션을 실행하는데 영향은 없다.

- 하지만 화면을 덮어서 애플리케이션을 실행할 수 없게 하기 때문에, 항상 해당 에러를 해결하고 넘어가야 한다. 생산성에 영향을 준다.

	따라서, 이 에러를 무시하고도 애플리케이션을 개발할 수 있게 설정해 볼 것이다.
	
	해당 프로젝트 폴더에서 새파일로 vue.config.js를 만들어 준다.
	
   	 ==> 설정 파일이라고 보면 된다.


<img src="./imgs/end17_2.png" />

- 새롭게 생성한 vue.config.js파일에 위의 이미지처럼 작성해 주면 ESLint 에러가 브라우저에서 화면을 덮지 않고, 터미널에서만 보여지게 된다.

	===> 생산성이 높아짐!


<h3> 18강 (ESLint 설정 파일 안내) </h3>

- ESLint  : ESLint는 JavaScript 코드에서 발견 된 문제 패턴을 식별하기위한 정적 코드 분석 도구입니다.

<img src="./imgs/end18.png" />

===> rules: { } 의 “no-console” : “off”




<h3> 19강 (Prettier 소개 및 ESLint와 같이 사용해야 하는 이유) </h3>

- prettier 사이트: 
https://prettier.io/
- Prettier 사이트에서 get started를 누른 후 목록 중 Configuring Prettier의 Options를 보자.

- Prettier를 .eslintrc.js에서 설정해야하는 이유가 있다. 그 이유는 만약 프로젝트 폴더에서 .prettierrc라고 새 파일을 만들면 여기 파일에서 정의한 기준으로 프로젝트를 작성하게 된다. 하지만 이렇게 하면 .eslintrc.js에서 정의한 rules와 충돌하기 때문에, .eslintrc.js가 우선시 되어야 한다. 따라서, Prettier가 .eslintrc.js에 들어가야 하는 것이다.




<h3> 20강 (ESLint에 Prettier 규칙 적용) </h3>

- prettier를 설정해서 기준을 정해 놓으면 , 팀을 이뤄 프로젝트를 할 때 통일된 규칙의 코드를 작성할 수 있는 이점이 있다.

<img src="./imgs/end20.png"/>

- Vue.js 개발 생산성을 높여주는 도구 3가지 :
https://joshua1988.github.io/web-development/vuejs/boost-productivity/




<h3> 21강 (ESLint 플러그인 설치 및 설정 변경) </h3>

- ESLint 플러그인을 다운로드 후, VSCode의 설정화면 접속.

  (설정 메뉴 접속 단축키)
  
   : 윈도우 기준 ctrl + ‘,’
   
   : 맥 기준 command + ‘,’
   
- ‘설정’에서 eslint를 검색 후 아래로 내리면 Eslint: Probe가 나온다. 이것이 eslint가 동작할 파일의 확장자들을 나열한 것이다. 
- 조금 더 내리면 Eslint: Validate가 있다. ‘settings.json에서 편집’버튼을 눌러 접속 후, 아래의 코드를 추가해 준다.


- 깃헙 브랜치에 올라간 코드 확인하기(브라우저에 깃헙 계정 로그인 필요) :
https://github.com/joshua1988/vue-til/blob/complete/settings.json

		코드 내용
		{
		  // ESLint
		  "eslint.validate": [
		    {
		      "language": "vue",
		      "autoFix": true
		    },
		    {
		      "language": "javascript",
		      "autoFix": true
		    },
		    {
		      "language": "javascriptreact",
		      "autoFix": true
		    },
		    {
		      "language": "typescript",
		      "autoFix": true
		    },
		    {
		      "language": "typescriptreact",
		      "autoFix": true
		    }
		  ],
		  "editor.codeActionsOnSave": {
		    "source.fixAll.eslint": true
		  },
		  // don't format on save
		  "editor.formatOnSave": false
		}





<h3> 22강 (Prettier 플러그인 확인 및 설정할 때 주의 사항) </h3>

- Prettier같은 경우에는 Eslint를 쓸 때 같이 활용해야 한다기 보다는, Prettier플러그인이 설치되어 있을 경우 해제해야 한다는 관점에서 보면 된다.
- prettier검색 후 우측클릭 후 사용안함 눌러준 후, ‘다시 로드 필요’버튼을 클릭해줘서 프로젝트를 다시 실행시켜 준다.
- 그런 후, cmd + ‘,’을 눌러 ‘설정’에 접속 후 format on save를 검색해 준 후, format on save의 체크 박스를 체크되지 않게 바꿔준다.

    ===> eslint로 정리할지 format on save로 정리할 지 충돌이 일어나기 때문에 꺼주는 것.

	====아니 근데 왜 내 VSCode에서는 안되는거야….?휴…
	====해결 되었다!!! 내가 코드 덜 적어놓고서 몰랐음...ㅋㅋ....



<h3> 23강 (프로젝트 레벨로 ESLint 규칙을 관리해야 하는 이유와 ESLint 규칙 설명) </h3>

- 개발 tool의 기능에 의존하게 되면 개발 tool이 달라졌을 때, 코드가 일관되지 못할 것이다. 따라서 개발 tool의 종류에 영향을 받지 않고, 프로젝트 소스 레벨에서 설정을 관리하는게 팀차원에서 개발하는게 생산성이나 효율이 높다는 것을 알고 있자.
- 프로젝트 폴더 속 폴더 중에 node_modules는 package.json 속에 정리되어 있는 라이브러리의 목록을 볼 수 있다. 목록 중 @vue를 눌러보면 eslint, prettier들이 있는 걸 볼 수 있다.



<h3> 24강 (파일의 절대 경로를 설정해야 하는 이유) </h3>

	import Demo from '../../demo/basic/Demo';
- 이렇게 ../ 으로 파일 경로를 접근하는 것은 거슬러 올라가는 것으로 파일의 ‘상대 경로’라고 한다.

    파일이 깊어질수록 파일을 거슬러 올라가는 ../ 가 많이 붙게 되므로, 나중에 assets에 img를 넣는다거나 font를 관리할 때에 번거로워질 수 있다.
- 따라서, ../ 대신 앞에 @를 사용해서 접근할 수 있도록 하자.


- 단, VSCode가 아닌 다른 개발 tool일 경우에는 적용되지 않을 수도 있단 점 알아두자!!!




<h3> 25강 (파일을 절대 경로로 찾기 설정) </h3>

- 프로젝트 폴더를 열고, jsconfig.json이라는 파일을 새로 만들어 준다.(이는 프로젝트가 아닌 VSCode를 위한 설정이라는 것을 잊지 말자!)

<img src="./imgs/end25.png"/>

- jsconfig.json 파일 링크(Vue TIL 리포지토리):
https://github.com/joshua1988/vue-til/blob/complete/jsconfig.json

- VSCode의 jsconfig.json 파일 설명 글:
https://code.visualstudio.com/docs/languages/jsconfig




<h3> 26강 (애플리케이션 코딩 컨벤션 및 뷰 스타일 가이드 소개) </h3>

- 애플리케이션을 제작할 때 사용할 코딩 컨벤션.
- 이번 강의에서 제작하는 애플리케이션은 style guide문서에서 우선순위 A: 필수, 우선순위 B: 매우 추천함을 기준으로 제작할 것이다.


- Vue.js 스타일 가이드 문서 :
https://kr.vuejs.org/v2/style-guide/index.html




<hr/>




<h2>4. 라우터 & 컴포넌트 설계</h2>

<h3> 27강 (깃헙 리포지토리 안내 및 클론) </h3>

- 아래의 깃헙 리포지토리에서 clone 주소를 복사한다.
- finder에서 END-GAME폴더에서 터미널을 오픈한 후, 

    “ $ git clone 복사한 주소 ” 를 적는다.
- 새로운 프로젝트 파일이 생성된다.
- 생성 후 터미널에서 $ ls를 입력해 설치가 되었는지 확인해 본다.
- VSCode를 키고 해당 프로젝트에서 터미널을 오픈한다.
- 터미널에서 $git checkout 1_setup 을 입력해 설치한다. 
- 설치 후 $npm I 를 이용해 설치를 완료한다.

- 수업 깃헙 리포지토리 안내 :
https://github.com/joshua1988/vue-til




<h3> 28강 (뷰 라우터 설치 및 연결) </h3>

- 이번 강의에서 만들 애플리케이션은 화면 구성이 ‘로그인’, ‘회원가입’, ‘메인’, ‘추가/수정’으로 될 것이다.
- Vue.use( ) : 기본적으로 플러그인을 실행하기 위해서, 초기화하기 위해서 필요한 코드.




<h3> 29강 (페이지 컴포넌트 생성 및 연결) </h3>

<img src="./imgs/end29.png"/>


<h3> 30강 (라우팅 동작 확인) </h3>

<img src="./imgs/end30.png"/>



<h3> 31강 (코드 스플리팅 소개 및 적용) </h3>

- App.js 안에 모든 페이지들의 정보가 들어가있는 것이다.
- 실제 애플리케이션에서는 화면의 갯수가 매우 많다. 따라서 그 수많은 페이지를 한번에 다 로드해 오는 것은 굉장한 시간이 걸린다. 
- 따라서, 만약 30페이지일 경우 첫 페이지가 로그인이면 로그인 페이지만 가져오고, 나머지 29페이지는 해당 url로 이동했을 때만 들고오는 것이 코드 스플리팅의 역할이다.
- 이렇게 싱글페이지 애플리케이션을 만들 때 어떤 페이지를 코드 스플리팅할지 고민해서 제작하면, 초기에 애플리케이션을 로딩하는 속도는 줄어들고, 사용자의 경험이 향상되는 결과를 얻을 수 있다!. 


- Window History API :
https://developer.mozilla.org/en-US/docs/Web/API/Window/history

- 웹팩 코드 스플리팅 문서 :
https://webpack.js.org/guides/code-splitting/

- Vue.js 다이나믹 임포트 문서 :
https://vuejs.org/v2/guide/components-dynamic-async.html#ad

<img src="./imgs/end31.png"/>
===> 29강의 index.js에서 작성한 routes와 달리 코드 스플리팅을 이용해 연결시켜 줬다.


<h3> 32강 (초기 진입 페이지 설정) </h3>

- redirect 설정 : url을 입력해서 첫 화면에 접속 했을 때 연결될 루트를 입력해 주는 것.

<img src="./imgs/end32.png"/>


- 뷰 라우터 오픈 소스 :
https://github.com/vuejs/vue-router



<h3> 33강 (없는 페이지를 접근할 때의 라우터 처리) </h3>

- 라우터의 콜백 기능 : 라우터의 속성에 정해지지 않는 즉, 없는 url에 대해 반응하는 라우터를 의미한다.

<img src="./imgs/end33_1.png"/>
<img src="./imgs/end33_2.png"/>
<img src="./imgs/end33_3.png"/>
==> end33_3.png를 보면, 라우터에서 등록하지 않은 /main으로 url을 연결해 주었고, 콜백기능에 의해서 @/views/NotFoundPage.vue로 이동되어 Page is not found라는 글자가 보인다.



<h3> 34강 (history mode 설정 및 싱글 페이지 애플리케이션 배포할 때 주의 사항) </h3>

- router에서 mode: ‘history’ 를 작성해 주면 url에서 /#/이 붙는 것을 제거해 준다.

- 뷰 라우터 History Mode 주의 사항 문서 :
https://router.vuejs.org/guide/essentials/history-mode.html




<hr/>





<h2>5. 회원 가입 페이지 개발</h2>

<h3> 35강 (회원 가입 페이지 개발을 위한 준비) </h3>

- vue-til-server폴더를 열어 API 서버 실행 명령어인 npm run dev를 입력해 준다.
- vue-til-server는 api파일들, vue-til은 애플리케이션.



<h3> 36강 (헤더 컴포넌트 마크업 및 회원 가입 컴포넌트 생성) </h3>

- page컴포넌트는 드라이하게 남아있는 것이 좋다. 비지니스 로직이 많이 연계되는 것보다는 비지니스 로직을 들고있는 컴포넌트를 등록할 수 있게 하는 게 좋다.

<img src="./imgs/end36.png"/>


 
<h3> 38강 (회원 가입 폼 데이터 바인딩 및 이벤트 연결) </h3>

- vim + tab키 : 

		import New from ‘@/components/New.vue';
- vda + tab키 : 


 		data() {
        	 return {
                   key: value
       		 }
    		},



<img src="./imgs/end38.png"/>




<h3> 39강 (회원 가입 API 요청을 위한 문서 확인) </h3>

- npm i axios : axios 설치.



<h3> 40강 (API 폴더와 회원 가입 API 함수 생성) </h3>

- 설치한 axios는 package.json에서 확인할 수 있다.
- axios를 바로 SignupForm.vue에서 import해서 사용하는 것보다는, src폴더 내에 따로 api폴더를 만들어서 사용하는 것이 훨씬 구조적이면서 나중에 수정할 때에도 편리하다.
<img src="./imgs/end40.png"/>

- VSCode는 웹기술로 만들어진 개발 툴이다. 이 개발 툴 자체가 타입스크립트로 만들어 진 것이다.

- 타입스크립트 핸드북 :
https://joshua1988.github.io/ts/




<h3> 41강 (회원 가입 API 호출과 주의 사항) </h3>

<img src="./imgs/end41_1.png"/>

	- console의 Network의 XHR은 네트워크 요쳥에 대해서만 필터링을 해서 볼 수 있는 것이다.
<br/><br/>

<img src="./imgs/end41_2.png"/>

<img src="./imgs/end41_3.png"/>




<h3> 42강 (회원 가입 이후의 동작 구현) </h3>

- 40강에서는 api를 요청하고 호출하는 확인만 했었는데, api상으로 의미가 있으려면 회원가입을 했을 때 회원가입이 완료되었다는 메세지를 뜨게 하는 등의 부가적인 동작들을 하기 위해서 submitForm( ) { }을 비동기 처리해줘야 한다.

<img src="./imgs/end42_1.png"/>

	===> .then( ).catch( )를 사용해서 작성해줘도 된다.
		(이게 기존에 내가 배웠고 사용했던 방법)
<br/><br/>

<img src="./imgs/end42_2.png"/>

	===> asyne await(어씽크 어웨잍)를 이용해서 처리할 수 도 있다.

<br/> <br/>

<img src="./imgs/end42_3.png"/>

	===> 그 결과를 response로 받아볼 수 있다.

<br/><br/>

- Network에서 데이터들이 잘 넘어왔는지 확인을 해야한다. 

<br/><br/>

<img src="./imgs/end42_4.png"/>



- async await 정리글 :
https://joshua1988.github.io/web-development/javascript/js-async-await/

- ES6 템플릿 리터럴(백틱) 정리글 :
https://joshua1988.github.io/es6-online-book/template-literal.html

- ES6 Destructuring 정리글 :
https://joshua1988.github.io/es6-online-book/destructuring.html




<hr/>





<h2>6. 실무 환경을 위한 프로젝트 설정</h2>
<h3> 43강 (API 설정 공통화) </h3>

<img src="./imgs/end43_1.png"/>

	==> 공통된 url을 보다 효율적으로 사용할 수 있도록 공통화를 해줄 필요가 있다.

<br/><br/>

<img src="./imgs/end43_2.png"/>

	===> 공통된 부분을 config를 선언해서 별도로 작성해 준 것이다.
	===> 기존에 내가 배웠고, 사용했던 방식.
	
<br/><br/>	

<img src="./imgs/end43_3.png"/>

	===> 기존에 사용하던 방식 대신 이 방식을 쓰면 더 깔끔하게 작성 가능하다.
	===> 필요한 것들을 작성 가능.

<br/><br/>

<img src="./imgs/end36.png"/>


- axios create() 문서 :
https://github.com/axios/axios#axioscreateconfig




<h3> 44강 (env 파일과 설정 방법) </h3>

- api주소를 환경변수로 관리하는 방법.
- 프로젝트에 .env파일을 만들어 준다.

    => .env는 ‘키=값' 형태로 정의할 수 있는 환경 변수 파일.
    
<img src="./imgs/end44_1.png"/>

	==> .env파일에 API_URL을 작성해 준다.
        	‘VUE_APP’라는 접두사가 붙은 변수는 자동 로드가 된다.

<br/><br/>

<img src="./imgs/end44_2.png"/>

	==> process.env.~를 이용해서 보다 편리하게 공통된 url을 불러올 수 있다.

- 웹팩 DefinePlugin 문서 :
https://webpack.js.org/plugins/define-plugin/



<h3> 45강 (Vue CLI의 env 파일 규칙과 실무 환경 구성 방법) </h3>

- .env 파일 규칙에 대해 살펴보자.

<img src="./imgs/end45_1.png"/>

	===> 대부분의 웹서비스는 퍼블릭한 도메인에 오픈이 되기 때문에, 기본적으로 localhost를 바라보는 것은 맞지 않다.
	===> 따라서, 서버에 배포했을 때 들어갈 url을 따로 만들어 줬다. 
	===> 하지만 .env에서 분리해서 관리하는게 아니라 .env.development를 만들어 관리해준다.

<br/>

- 프로토타이핑 단계를 development라고 vue-cli에서 내부적으로 정의하고 있다.  
- 따라서,  .env.development에 localhost url를 옮겨준다.

<br/>
<img src="./imgs/end45_2.png"/>
<img src="./imgs/end45_3.png"/>

	===> .env는 이렇게 3가지 파일이 사용 가능하다.
	===> .env.production에 배포했을 때의 url을 넣어준다. (강의 실습에서는 https://vue-til.com/을 넣어주면 된다.)

	===> npm run build를 했을 때 .env.production이 들어가게 되고, 로컬서버를 띄웠을 때는 .env.development가 들어가게 된다.
	
<br/><br/>

<img src="./imgs/end45_4.png"/>

	===> .env.production이나 .env.development파일이 없을 경우 .env파일이 가장 높은 우선순위를 가지게 된다.


<br/>


- 설정 파일을 변경했을 때에는 서버를 껐다가 재실행해줘야 한다. 웹팩이 설정이 변경된 것을 인식하지 못하기 때문.


- Vue CLI env 파일 규칙 문서 :
https://cli.vuejs.org/guide/mode-and-env.html#modes-and-environment-variables




<hr/>





<h2>7. 로그인 페이지 개발</h2>

<h3> 46강 (로그인 폼 컴포넌트 생성 및 마크업) </h3>

- LoginPage.vue 역시 드라이하게 냅두고, LoginForm.vue 컴포넌트를 제작해서 연결시켜준다.



<h3> 48강 (로그인 API 문서 확인 및 API 함수 생성) </h3>

<img src="./imgs/end48.png"/>



<h3> 49강 (로그인 기능 구현) </h3>

<img src="./imgs/end49.png"/>

	 ===> 48강에서 작성했던 LoginForm.vue의 methods를 바꿔줌. (api를 들여와서 수정)
<br/>


<h3> 50강 (에러가 났을 때의 대처 방법과 로그 분석하는 방법) </h3>

- 실제 애플리케이션 개발할 때에는 기능보다도 에러를 잘 처리하는게 완성도 높은 애플리케이션을 만들 수 있다.

<img src="./imgs/end50_1.png"/>

	===> 로그인 정보가 틀려서 에러가 뜬 상태. 당황하지 말고 위에서부터 에러를 하나하나 살펴보자. 
	===> post요청을 했는데 401(Unauthorized)이 뜬 상태.

	===> 401코드 때문에 에러가 났다고 나와있다.
	===> <LoginForm>에서 에러가 발생했다고 나와있다.
	===> 하지만 정확히 어디서 발생했는지는 나와있지 않다.
		 따라서, 에러 처리를 잘해줘야 디버깅도 수월해지고 사용자 입장에서도 사용성이 깨지지 않게 된다.
<br/>

<img src="./imgs/end50_2.png"/>

	===> Network패널로 이통해서 login을 눌러보면, 동일한 url로 요청을 했지만 권한이 없다는 의미의 401이 떠있다.
	===> 옆의 Preview를 살펴보자.
<br/>

<img src="./imgs/end50_3.png"/>

	===> Network패널의 Preview를 살펴보면 ‘인증이 실패했다. 비밀번호가 틀렸다.’라는 메세지를 보내줌.
<br/>

- 다음 강의(51강)에서 이 에러부분들을 어떻게 개선할 수 있을지 async await의 에러처리 방법에 대해 배울 것이다.






<h3> 51강 (네트워크 에러 확인 방법과 에러 처리 코드 구현) </h3>

- try{ }와 catch(error) { }를 이용해서 작성해 준다.

<img src="./imgs/end51_1.png"/>

	===> try{ } 속에 기존의 로그인성공 로직을 넣어준다. 
	===> catch( ) { } 에는 로그인실패시 에러를 확인할 수 있도록 콘솔로 찍어준다.
<br/>

<img src="./imgs/end51_2.png"/>

	===> LoginForm.vue에서 에러를 콘솔에 찍히도록 코드를 작성했기 때문에, 비밀번호를 틀리게 친 경우 console에 에러가 뜬다. 
	===> 50강에서 에러를 나타내는 것은 LoginForm.vue 전체를 가리켜서 어디서 에러가 나는지 알 수 없었다.
	===> 하지만 이번에는 정확하게 43번째 라인을 가리켜 주기 때문에 try{ }안에서의 에러라는 것을 파악할 수 있게 된다.
<br/>

	===> 콘솔에 뜬 에러를 보면 POST요청에 대한 에러인 것을 알 수 있다. 따라서 이 에러는 안에 Response가 있다는 것을 알 수 있는 것이다.
	===> Network로 갔을 때, login의 Response가 들어온 것을 확인할 수 있다.
<img src="./imgs/end51_3.png"/>

	===> 따라서, LoginForm.vue로 돌아와서 catch(error) { }에서 콘솔로 찍을 때, console.log(error)이 아닌 console.log(error.response)를 하게 되면 에러에 대한 상세 내용들을 콘솔에 띄울 수 있게 된다.
	
<br/>

<img src="./imgs/end51_4.png"/>

	===> Network의 Response에서 보았던 메세지는 data에 나타나는 것을 볼 수 있다.


- 이처럼, 일반적으로 백엔드에서는 에러가 나면 에러 메세지나 에러 코드를 보내주기 때문에, 그런걸 받아서 일차적으로는 화면에 노출시키는게 좋은 에러 헤결 방법이다.(콘솔 말고!!)





<h3> 52강 (에러 메시지 출력 및 에러 피드백 표시 방법) </h3>

- 에러가 났을 때, 에러 메세지가 콘솔로 출력되면 사용자 입장에서는 알 수 없다. 따라서 무조건 화면에 표시를 해줘야 하는게 기본적인 웹의 사용성이다.

<img src="./imgs/end52_1.png"/>

	===> data에 만들어놓았던 logMessage를 이용해서 error을 넣어준다.
	===> 그 결과, 로그인시 에러가 발생하면 브라우저 화면에 메세지가 뜬다.

<img src="./imgs/end52_2.png"/>

<br/>


+) 
- 로그인 input창을 비워주는 함수실행코드의 위치는 상황에 맞게 넣어주면 된다. 
- try{ }나 catch( ){ } 중 상황에 맞게 넣어주면 됨. 만약 중복된다 싶을 때에는 try와 catch의 뒤에 finally{ }를 만들어서 넣어주면 된다.
<img src="./imgs/end52_3.png"/>





<h3> 53강 (사용자 폼 유효성 검사 안내) </h3>

- 로그인 input에서 
	-  입력된 id와 pw가 없으면 로그인이 활성화가 되지 않도록 하고, 
	-  id입력 input에서 이메일이 아닌 것을 입력했을 경우에도 로그인이 활성화되지 않도록 할 것이다.
- 이메일이 아닌 것을 찾는 정규식을 써야 하는데 새롭게 만들지 않고, 아래의 링크에서 가져다 쓸 것이다.
- 정규식을 LoginForm.vue의 script안에 적어도 되지만, loginForm뿐만 아니라 signup을 할 때 부터 사용되어야 하기 때문에 

	src폴더 밑에 utils폴더를 새롭게 만들어서 작성해준다.(validation.js파일 생성)

- Email Validation 정규 표현식 코드 :
https://stackoverflow.com/questions/46155/how-to-validate-an-email-address-in-javascript

<img src="./imgs/end53_1.png"/>
<img src="./imgs/end53_2.png"/>



<h3> 54강 (computed 속성을 이용한 이메일 형식 검사) </h3>

- validation이라고 하면 username에 들어가는 값들은 validateEmail 함수를 돌려 확인할 것이다.
- 일반적으로 computed를 사용하게 될 것이다. data의 변화에 따라서 그 내용들을 자동으로 계산해주는 연산식이다.

<img src="./imgs/end54_1.png"/>
<img src="./imgs/end54_2.png"/>

	===> 옳은 id를 입력했을 때, vue의 LoginForm의 isFormValid가 true임을 볼 수 있다.	
<br/>

<img src="./imgs/end54_3.png"/>

	===> 잘못된 id를 입력했을 때, vue의 LoginForm의 isFormValid가 false임을 볼 수 있다.
<br/>

<img src="./imgs/end54_4.png"/>

	===> <button>을 조건이 성립할 때에만 활성화 시켜준다. 
	===> (isUsernameValid는 computed의 isFormValid 이름을 수정해준 것임.)
	===> !isUsernameValid : input에 입력된 id를 한글자한글자 비교해서 틀릴 경우 false일 때 button을 비활성(disabled)하게 함.
	     !password : password가 입력되지 않았을 경우 button을 비활성해줌.




<h3> 55강 ([퀴즈] 회원 가입 컴포넌트 유효성 검사) </h3>

- SignupForm.vue의 input들을 LoginForm.vue에서처럼 만들어 보세요~~
